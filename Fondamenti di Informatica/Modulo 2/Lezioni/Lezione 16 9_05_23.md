# Problemi e codifiche
## Dai linguaggi ai problemi
Le teorie della calcolabiltà e della complessità sono fondate sul concetto di *appartenenza di una parola ad un insieme di parole*: un concetto semplice, elegante, formale e rigoroso.
Tuttavia, nella vita reale, non ti capita spesso di domandarti “ma questa parola apparterrà forse a questo insieme?”
Nella vita reale, piuttosto, ti capita di dover trovare le soluzioni ad istanze di problemi. E, allora, queste teorie sarebbe bello trasferirle nel mondo dei problemi.
Ma il concetto *“trovare la soluzione ad una istanza di un problema”* è, senza dubbio, più arbitrario (se vogliamo, più evanescente), *meno rigoroso* di quello di appartenenza di una parola ad un insieme di parole.
E, allora, questo concetto di *“trovare la soluzione ad una istanza di un problema”* dobbiamo renderlo meno arbitrario, ossia, *più rigoroso*!
Dobbiamo **formalizzarlo**.
Questo comporterà la gestione di numerose questioni.
Allora, cominciamo: come possiamo ***schematizzare un “problema”***?
Di qualunque problema stiamo parlando, la struttura di un problema è sostanzialmente la seguente:
1. dati un insieme di oggetti conosciuti – l’insieme dei dati che costituisce un’istanza del problema;
2. all’interno di un secondo insieme di oggetti – l’insieme delle soluzioni possibili;
3. cercare gli oggetti che soddisfino certi vincoli; 
4. e, sulla base degli oggetti trovati, fornire un qualche tipo di risposta.
>[!info] 
>Nella dispensa 7, al paragrafo 7.1, trovate un po’ di esempi.

## Formalizzare problemi
**Esempio**: *dato un numero intero…* (segue richesta relativa ai divisori del numero)
Di qualunque problema stiamo parlando, la struttura di un problema è sostanzialmente la seguente:
1. *dati un insieme di oggetti conosciuti* – l’insieme dei dati che costituisce una $istanza$ del problema;
2. all’interno di un secondo insieme di oggetti – l’insieme delle soluzioni possibili;
3. cercare gli oggetti che soddisfino certi vincoli 
4. e, sulla base degli oggetti trovati, fornire un qualche tipo di risposta

**Dati un insieme di oggetti conosciuti**: dobbiamo descrivere le istanze del problema, ossia in cosa consiste ciascuna istanza del problema.
Descriviamo le istanze del problema definendo un insieme  - l’*insieme delle **istanze***.
Un elemento di  corrisponde ad una istanza del problema nell’ESEMPIO: $=$ .

**All’interno di un secondo insieme di oggetti – l’insieme delle soluzioni possibili**: dobbiamo descrivere cosa ci viene richiesto di cercare.
Descriviamo le soluzioni possibili per una istanza x del problema definendo un insieme $S(x)$.
$S(x)$ descrive tutti gli oggetti che dobbiamo testare per verificare se soddisfano i vincoli del problema, nell’ESEMPIO: $S(x)=\{y\in\mathbb N:y\leq x\}$.

**Cercare gli oggetti che soddisfino certi “vincoli”**: dobbiamo descrivere quali oggetti, all’interno delle soluzioni possibili, soddisfano la richiesta del problema. 
Descriviamo le soluzioni possibili associate ad una istanza $x$ che soddisfano i vincoli del problema definendo un insieme $\eta(S(x))$ di *soluzioni effettive* per l’istanza $x$
$\eta(S(x))$è l’insieme che contiene tutti gli oggetti che sono soluzioni possibili per x e che soddisfano i vincoli del problema, nell’ESEMPIO: poiché il problema si pone qualche domanda circa i divisori di un dato numero $x$,  $\eta(S(x))=\{y\in S(x): y\space è\space divisore\space di\space x\}$.

**Sulla base degli oggetti trovati, fornire un qualche tipo di risposta** : dipendentemente dalla domanda posta dal problema, dobbiamo rispondere fornendo quanto ci viene richiesto.
Descriviamo la risposta al problema definendo una funzione $\rho$ che associa all’insieme delle soluzioni effettive per l’istanza $x$ una risposta scelta nell’insieme $R$ delle risposte.E, per chiarire questa questione, dobbiamo entrare nel dettaglio di *(segue richiesta relativa ai divisori del numero)*

>[!important]- Esempio 1

**Dato un numero intero $n$, elencare tutti i divisori di $n$**.
*Sulla base degli oggetti trovati, fornire un qualche tipo di risposta* : dipendentemente dalla domanda posta dal problema, dobbiamo rispondere fornendo quanto ci viene richiesto. In questo caso, $R = 2^{\mathbb N}$ .
Ossia, la risposta ad una istanza del problema è un sottoinsieme di  $\mathbb N$ , e, per ogni istanza n del problema, $\rho(\eta(S(n))) = \eta(S(n))$.

>[!important]- Esempio 2

**Dato un numero intero $n$, verificare se $n$ è primo**.
*Sulla base degli oggetti trovati, fornire un qualche tipo di risposta* : dipendentemente dalla domanda posta dal problema, dobbiamo rispondere fornendo quanto ci viene richiesto. In questo caso, $R = \{ vero, falso\}$ e, per ogni istanza $n$ del problema, $\rho(\eta(S(n))) =[\rho(S(n))=\{1,n\}]$.

>[!important]- Esempio 3

**Dato un numero intero $n$, calcolare un divisore $d$ non banale di $n$ (ossia $d\gt 1$ e $d\lt n$)**.
*Sulla base degli oggetti trovati, fornire un qualche tipo di risposta* : dipendentemente dalla domanda posta dal problema, dobbiamo rispondere fornendo quanto ci viene richiesto. In questo caso, $R = \mathbb N$, e, per ogni istanza n del problema, $\rho(\eta(S(n)))$ è un qualunque elemento di $\eta(S(n))$ che sia diverso da $1$ e da $n$.
**ATTENZIONE**: $d$ potrebbe *essere primo*! In questo caso, … secondo voi, che si fa?

>[!important]- Esempio 4

**Dato un numero intero $n$, calcolare ***il più grande divisore* non banale $d$ di $n$**.
In questo caso, ancora, $R=\mathbb N$, e, per ogni istanza n del problema, $\rho(\eta(S(n)))$ è **il più grande** elemento di $\eta(S(n))$ che sia diverso da $1$ e da $n$. 
**ATTENZIONE**: $d$ potrebbe *non esistere*! In questo caso, … secondo voi, che si fa?
## Tipi di problemi
**ESEMPIO 4**: dato un numero intero $n$, calcolare **il più grande divisore** non banale $d$ di $n$  (ossia, $d > 1$  e $d < n$).
È un *problema di ottimizzazione*, in quanto alle soluzioni effettive è associata una misura e viene richiesto di trovare una soluzione effettiva di misura massima (come in questo caso), oppure minima; 
**ESEMPIO 3**: dato un numero intero $n$, calcolare un divisore non banale $d$ di $n$  (ossia, $d > 1$  e $d < n$). È un *problema di ricerca*, in quanto viene richiesto di trovare (e mostrare) una qualunque soluzione effettiva (sono i problemi con i quali abbiamo maggiore confidenza);
**ESEMPIO 1**: dato un numero intero $n$, elencare *tutti* i divisori di $n$. È un *problema di enumerazione*, in quanto ci viene richiesto di elencare tutte le soluzioni effettive;
**ESEMPIO 2**: dato un numero intero $n$, verificare se $n$ è *primo*. Questo è un *problema di decisione* (o **decisionale**), in quanto ci viene richiesto di decidere se l’istanza possiede una certa proprietà.
## Problemi e macchine
Naturalmente, i due diversi tipi di macchine di Turing risolvono diversi tipi di problemi:
1. Trasduttori per i problemi di ricerca, di enumerazione, e di ottimizzazione; 
2. Riconoscitori per i problemi di decisione.
La Teoria della Complessità si occupa, per lo più, di decidere dell’appartenenza di parole ad insiemi di parole, come abbiamo studiato sino ad ora, utilizzando riconoscitori. 
Sembra naturale estendere quanto studiato nella dispensa 6 ai problemi decisionali: per questo ci occuperemo, d’ora in avanti di *soli problemi decisionali*.
## Problemi decisionali
Abbiamo visto che un problema, in generale, può essere descritto da una quintupla $\langle \mathcal I, S,\eta ,\rho , R \rangle$ , dove
1. $\eta$ è il sottoinsieme di $S$ che specifica quali, fra le soluzioni possibili, sono le soluzioni effettive per una data istanza $x\in\mathcal I$;  
2. $\rho$ è la funzione che associa all’insieme delle soluzioni effettive $\eta(S(x))$ una risposta (elemento di $R$) all’istanza $x$ del problema;
Nel caso di problemi decisionali, sappiamo che $R = \{ vero, falso\}$. Questo significa che, in effetti, $\rho$ *è un predicato*, ossia, una funzione booleana, o, per dirla semplice, una proposizione logica il cui valore di verità dipende da qualche incognita.
Allora, possiamo riassumere $\eta,\rho,R$ in un unico predicato $\pi$: $\pi(x,S(x))=$ **vero se e soltanto se l’insieme delle soluzioni possibili per x soddisfa i vincoli del problema**. E, quindi, *un problema decisionale è descritto da una tripla* $\langle\mathcal I, S,\pi\rangle$.
### Problemi decisionali : Esempi
>[!important]
>Un problema decisionale è descritto da una tripla $\langle\mathcal I , S,\pi\rangle$. 

>[!warning]- Esempio 1 
>Dati un grafo non orientato $G$, una coppia di nodi $s$ e $t$, e un intero $k$, decidere se esiste in $G$ un percorso da $s$ a $t$ di lunghezza $=k$.

1. $\mathcal I= \{\langle G, s, t, k \rangle\:$ G è un grafo non orientato $\land\space s,t$ sono due nodi di $G\land k\in\mathbb N\}$;
2. $S(G, s, t, k)=\{\langle u_0, u_1, … , u_k\rangle :$ per $i=0, … ,k, u_i$ è un nodo del grafo };
3. $\pi(G, s, t, k, S(G, s, t, k))=\exists\langle u_0, u_1, … , u_k\rangle\in S(G, s, t, k) : s=u_0\land t=u_k\land\forall i=0, … ,k-1, [ (u_i , u_{i+1})$ è un arco del grafo ].

>[!warning]- Esempio 2 
>Dato un insieme $X$ di variabili booleane ed un predicato $f$, definito sulle variabili in $X$ e contenente i soli operatori $\land,\lor$ e $\lnot$ , decidere se esiste una assegnazione $a$ di valori in $\{vero, falso\}$ alle variabili in $X$ tali che $f(a(X))=vero$.

1. $\mathcal I=\{ \langle X,f\rangle:X$ è un insieme di variabili booleane $\land f$ è un predicato su $X\}$
2. $S(X,f)=\{a:X\rightarrow\{vero, falso\} \}$ (S è l’insieme delle assegnazioni di verità alle variabili in X)
3. $\pi(X,f, S(X,f) )=\exists a\in S(X,f) : f(a(X)) = vero$.
*Nota bene*: ciascun problema decisionale può essere descritto da diverse triple $\langle\mathcal I, S,\pi\rangle$.
## Da problema a linguaggio
A questo punto, formalizzato il concetto di problema decisionale, siamo *quasi* pronti ad estendere quanto abbiamo studiato sulla complessità dei linguaggi alla complessità dei problemi decisionali. E, visto che la complessità dei linguaggi è studiata utilizzando la Macchina di Turing, utilizzeremo la Macchina di Turing anche per studiare la complessità dei problemi decisionali.
Ma per utilizzare una macchina di Turing per risolvere un problema decisionale, anzi, per *deciderlo*, abbiamo bisogno di trasformare le *istanze* di quel problema in **parole**, altrimenti, cosa scriviamo sul nastro?
Ossia, occorre **codificare** opportunamente le istanze di un problema decisionale (e questa è una questione *parecchio* delicata).
## Codifica
>[!info]
>Nel paragrafo 7.4 viene introdotta la questione delle codifiche attraverso un esempio: l’ Esempio 2 che abbiamo visto poc’anzi

**Esempio 2**: *dato un insieme $X$ di variabili booleane ed un predicato $f$, definito sulle variabili in $X$ e contenente i soli operatori $\land,\lor$  e $\lnot$ , decidere se esiste una assegnazione $a$ di valori in $\{vero, falso\}$ alle variabili in $X$ tali che $f(a(X))=vero$*.
	$\mathcal I=\{\langle X,f\rangle : X$ è un insieme di variabili booleane $\land$ f e un predicato su $X\}$
Di questo problema viene considerato un caso particolare: **3SAT**
1. La funzione $f$ è in una forma particolare: $f = c_1\land c_2\land …\land c_m$
2. E ciascuna $c_j$ prende il nome di clausola ed è l’or ($\lor$) di tre letterali
3. Dove un letterale è una variabile o una variabile negata – tipo $x_1 \lor\lnot x_2\lor x_3$
Come codificare gli elementi di $\mathcal I$?
Abbiamo due possibilità:
1) codifichiamo la struttura di $f$ ;
2) codifichiamo “il significato” di $f$ .
**Codifica** $\chi_1$ : Codifichiamo la struttura di $f$
1. rappresentiamo ciascun elemento di $X = \{x_1 , x_2, ... , x_n\}$ con $n=|X|$ bit: $x_i$ ha l’i-esimo bit $1$ e tutti gli altri bit $0$ ;
2. rappresentiamo un letterale in una clausola mediante la rappresentazione della variabile corrispondente al letterale preceduta da $0$ se il letterale è la variabile non negata, preceduta da $1$ se se il letterale è la variabile negata.
3. gli $\lor$ in una clausola sono rappresentati da ’$2$’;
4. gli $\land$ fra due clausole sono rappresentati da ‘$3$’;
5. premettiamo alla codifica di $f$ tanti ‘$4$’ quanti gli elementi di $X$ – ossia, $|X|= ’4’$
Ad esempio, se $X = \{x_1, x_2, x_3\}$ e $f = c_1\land c_2$ con $c_1= x_1\lor  x_2\lor  x_3$ e $c_2 = x_1\lor  \lnot x_2\lor  x_3$, rappresentiamo $\langle X,f \rangle$  come :	
444 *0 100* 2 0 010 2 0 001 3 0 100 2 **1 010** 2 1 001.
**Codifica** $\chi_2$: Codifichiamo il "significato" di $f$ - codifichiamo $f$ in **Forma esplicita**
1. qualunque funzione è completamente descritta descrivendo i valori che essa assume in *tutti* i punti del suo insieme di esistenza
2. naturalmente, se una funzione è definita su non possiamo descrivere il valore che essa assume per ogni $n\in\mathbb N$  : in numeri naturali sono infiniti!
3. invece, la $f$ della nostra istanza $\langle X,f \rangle$ di **3SAT** è definita su $\{vero, falso\}^{|X|}$
4. quindi, poiché $X$ è un insieme finito, l’insieme di esistenza di $f$ è finito
5. allora, possiamo codificare $f$ in forma esplicita
6. mediante la sua **tavola di verità**.
**Codifica**$\chi_2$: Codifichiamo $f$ in *forma esplicita* mediante la sua tavola di verità.
Esempio: $X=\{x_1,x_2,x_3\}$ e $f=c_1\land c_2$ con $c_1=x_1\lor x_2\lor x_3$ e $c_2=x_1\lor\lnot x_2\lor\lnot x_3$.

![[Pasted image 20230509155657.png|center]]

Codificando vero con ‘$1$’ e falso con ‘$0$’, e scrivendo le righe della tavola una di seguito all’altra, separate da ‘$2$’.
	Esempio: 1111 2 *1101* 2 1011 2 1001 2 **0110** 2 0101 2 0011 2 0000 2
## Codifica e soluzione
**SOLUZIONE**: Data $\langle X,f \rangle$  istanza di **3SAT**, per decidere se $f$ è *soddisfacibile*, ossia, se esiste una assegnazione $a$ di valori in $\{vero, falso\}$ alle variabili in $X$ tali che f$(a(X))=vero$. Consideriamo il seguente algoritmo: 
1) calcola $n = |X|$; 
2) per ogni assegnazione di verità $a$ all’insieme delle $n$ variabili in $X$ : verifica se $f (a(X )) = vero$ e, in tal caso termina nello stato di accettazione $q_A$; 
3) se non ha mai terminato in $q_A$ al passo $2$, termina nello stato di rigetto $q_R$. 
Vediamo ora il precedente algoritmo implementato utilizzando entrambe le codifiche. 
