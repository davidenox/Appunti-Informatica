# Macchine, linguaggi, funzioni
## A questo punto
A questo punto è ragionevole porsi un po’ di domande:
1. Utilizzando la Macchina di Turing, si possono risolvere tutti i problemi? Oppure esiste qualche problema che non è risolubile con la Macchina di Turing?
2. E, se esiste qualche qualche problema che non è risolubile con la Macchina di Turing, non sarà forse possibile risolvere quel problema con un altro modello di calcolo?
La prima domanda cui risponderemo è la seconda. Prima di farlo, bisogna, però, essere più formali.
>[!info]
>Siamo alla dispensa 3, paragrafo 3.1

## Più in dettaglio
Una macchina di Turing (di tipo riconoscitore) è un oggetto che, se gli viene dato un certo input, quella risponde se quell’input soddisfa una certa proprietà, e l’input di una macchina di Turing è una parola (scritta con i caratteri di un certo alfabeto).
Quindi: una macchina di Turing (di tipo riconoscitore) è un oggetto che, se gli viene scritta una certa parola sul nastro, quella risponde se quella parola soddisfa una certa proprietà.
Allora, si può considerare l’insieme di tutte le parole che soddisfano quella certa proprietà e dire: “la macchina di Turing sa riconoscere le parole che appartengono a tale insieme”.
Ma non è abbastanza formale: che vuol dire **esattamente** *riconoscere*?
## Decidere un linguaggio
Dato un alfabeto $\Sigma$, un linguaggio L è un insieme di parole costituite di caratteri di $\Sigma$: ossia, $L\subseteq \Sigma^*$.
Un linguaggio L è deciso da una macchina di Turing T se:
1. per ogni x $\in$ L, la computazione T(x) termina in $q_A$;
2. per ogni x $\not\in$ L, la computazione T(x) termina in $q_R$.
Quindi, **le computazioni della macchina T che decide L terminano sempre**: sia che sul nastro di T venga scritto un input appartenente ad L, sia che sul nastro di T venga scritto un input non appartenente ad L, T giunge ad una conclusione.
Ossia, **T è sempre in grado di distinguere fra le parole di L e le parole che non sono in L**.
*Qualunque sia x in $\Sigma^*$, T ci dice se x è in L oppure no*.
### Decidere un linguaggio-Esempio
Prendiamo la macchina $T_{PAL}$ che abbiamo visto la scorsa lezione (con le due quintuple che rigettano se la parola in input ha lunghezza dispari): 
$$\begin{align}\\&
〈 q_0 , a, \square, q_a , D〉, 〈 q_0 , b, \square, q_b , D〉,\\&

〈 q_a , a, a, q_a , D〉,〈 q_a , b, b, q_a , D〉,〈 q_b , a, a, q_b , D〉,〈 q_b , b, b, q_b , D〉, \\&

〈 q_a , \square, \square, q_{a1} , S〉, 〈 q_b , \square, \square, q_{b1} , S〉, \\&

〈 q_{a1} , a, \square, q_2 , S〉,〈 q_{a1} , b, b, q_R , F〉,〈 q_{b1} , a, a, q_R , F〉,〈 q_{b1} , b, \square, q_2 , S〉, \\&

〈 q_2 , a, a, q_2 , S〉, 〈 q_2 , b, b, q_2 , S〉, 〈 q_2 , \square, \square, q_0 , D〉,\\&

〈 q_0 , \square, \square, q_A , F〉,\\&

〈 q_{a1} , \square, \square, q_R , F〉,〈 q_{b1} , \square, \square, q_R , F〉.\\&
\end{align}
$$
Ebbene, $T_{PAL}$ decide il linguaggio $L_{PPAL}$ (*P*ari e *PAL*indrome) seguente:
$$L_{PPAL} = \{ x1x2… x_{2n} \in\{a,b\}^*: n \in \mathbb{N} \wedge \forall i \in \{1, 2, ... , n\} [ x_i = x_{2n-i+1} ] \}$$
## Accettare un linguaggio
Dato un alfabeto $\Sigma$, un linguaggio L è un insieme di parole costituite di caratteri di $\Sigma$: ossia, $L\subseteq\Sigma^*$.
Un linguaggio L è **accettato** da una macchina di Turing T se:
1. per ogni x $\in$ L, la computazione T(x) termina in $q_A$;
2. per ogni x $\not\in$ L, la computazione T(x) **non** termina in $q_A$.
Quindi, se sul nastro di T viene scritto un input x appartenente ad L, siamo certi:    
(*a*) che T(x) termina;  
(*b*) che T(x) termina in $q_A$.
Se, invece, sul nastro di T viene scritto un input x non appartenente ad L, possiamo solo essere certi che T(X) non termina in $q_A$.
*Ma, se x non appartiene ad L, non è detto che T(x) termini in $q_R$, perché potrebbe anche non terminare*.
Ossia, T è solo in grado di dire che una parola appartiene a L (quando questo accade).
Modifichiamo le ultime due quintuple della macchina $T_{PAL}$ per ottenere la macchina $T_{PAL1}$ seguente:
$$\begin{align}\\&
〈 q_0 , a, \square, q_a , D〉, 〈 q_0 , b, \square, q_b , D〉,\\&

〈 q_a , a, a, q_a , D〉,〈 q_a , b, b, q_a , D〉,〈 q_b , a, a, q_b , D〉,〈 q_b , b, b, q_b , D〉, \\&

〈 q_a , \square, \square, q_{a1} , S〉, 〈 q_b , \square, \square, q_{b1} , S〉, \\&

〈 q_{a1} , a, \square, q_2 , S〉,〈 q_{a1} , b, b, q_R , F〉,〈 q_{b1} , a, a, q_R , F〉,〈 q_{b1} , b, \square, q_2 , S〉, \\&

〈 q_2 , a, a, q_2 , S〉, 〈 q_2 , b, b, q_2 , S〉, 〈 q_2 , \square, \square, q_0 , D〉,\\&

〈 q_0 , \square, \square, q_A , F〉,\\&

〈 q_{a1} , \square, \square, q_{a1} , F〉,〈 q_{b1} , \square, \square, q_R , F〉.\\&
\end{align}$$
Ebbene, $T_{PAL1}$ accetta il linguaggio $L_{PPAL}$ ma non lo decide; in particolare:
1. Accetta le parole palindrome di lunghezza pari;
2. Rigetta le parole non palindrome;
3. *Rigetta le parole palindrome di lunghezza dispari che hanno ‘b’ come carattere centrale*;
4. **Non termina sulle parole palindrome di lunghezza dispari che hanno ‘a’ come carattere centrale**.
Naturalmente, ogni linguaggio decidibile è anche accettabile – ma non viceversa.
Consideriamo il il linguaggio $L_{PPAL}$ (Pari e PALindrome) visto poc’anzi. Abbiamo visto la macchina $T_{PAL}$ che lo decide, ma abbiamo visto anche la macchina $T_{PAL1}$ che lo accetta senza deciderlo.
Insomma, $L_{PPAL}$ è un linguaggio decidibile oppure no?
Certo che è decidibile. Infatti, **esiste** una macchina che lo decide: la macchina $T_{PAL}$ (esiste: vuol dire che basta che ce ne sia una).
## Linguaggi complemento
Dunque, mentre una macchina che decide un linguaggio su un alfabeto $\Sigma$ sa ben comportarsi con tutte le parole in $\Sigma^*$ (per ogni parola in Σ* sa se accettare o rigettare), una macchina che accetta un linguaggio su un alfabeto $\Sigma$, invece, non sa sempre come comportarsi sulle parole in $\Sigma^*$ che non sono in L (potrebbe esistere una parola in $\Sigma^*-L$ sulla quale la macchina non riesce a capire che decisione prendere – e quindi non termina.
Sia $L\subseteq\Sigma^*$; chiamiamo **linguaggio complemento** di L il linguaggio $L^C=\Sigma^* -L$
Allora, possiamo dire che *la differenza fra decisione e accettazione di un linguaggio è il comportamento della macchina sul linguaggio complemento*.
Eccole ancora qui, le istanze negative...
## Teorema 3.1
**$L\subseteq\Sigma^*$ è decidibile se e soltanto se L è accettabile e $L^C$ è accettabile**.
*Se L è decidibile*, allora:
1. Chiamiamo T la macchina che decide L;
2. Bisogna costruire una macchina $T_1$ che accetta L e una macchina $T_2$ che accetta $L^C$;
3. Ebbene: la macchina $T_1$  è la stessa macchina T.
Infatti, per ogni x $\in$ L, T(x) termina in $q_A$.  
E la macchina $T_2$?
Facile: prendiamo T, invertiamo i suoi stati di accettazione e di rigetto e otteniamo $T_2$.
infatti, poiché T decide L, per ogni $x \in L^C, T_2(x)$ termina in $q_A$.
*Se L è accettabile e $L^C$ è accettabile* allora:
1. Si chiamano $T_1$ la macchina che accetta L e $T_2$ la macchina che accetta $L^C$;
2. Bisogna costruire una macchina T che decide L;
3. Si dota T di due nastri: T usa il nastro 1 per simulare $T_1(x)$ e il nastro 2 per simulare $T_2(x)$;
4. **Input di T**: una parola x scritta sul nastro 1;
5. **Inizializzazione**: T copia l’input x sul nastro 2, e poi inizia la computazione vera e propria:
	1) T simula **un passo** di $T_1(x)$: se quel passo fa accettare $T_1$ allora accetta,valtrimenti va a 2)
	2) T simula **un passo** di $T_2(x)$: se quel passo fa accettare $T_2$ allora rigetta, altrimenti va a 1)

poiché x $\in$ L oppure x $\not\in$ L , allora, prima o poi $T_1$ accetta o $T_2$ accetta: allora, T decide L.
Ma perché simuliamo un passo alla volta di ciascuna macchina?! Perché non simuliamo prima l’intera $T_1(x)$ e poi l’intera $T_2(x)$?
### Perché un passo alla volta?
La macchina $T_{PAL1}$ che abbiamo visto poc’anzi, accetta $L_{PPAL}$.
La seguente macchina, che chiamiamo $T_{PAL2}$, accetta : $L_{PPAL}^C$:
$$\begin{align} \\&
〈 q_0 , a, \square, q_a , D〉, 〈 q_0 , b, \square, q_b , D〉, \\&

〈 q_a , a, a, q_a , D〉,〈 q_a , b, b, q_a , D〉,〈 q_b , a, a, q_b , D〉,〈 q_b , b, b, q_b , D〉, \\&

〈 q_a , \square, \square, q_{a1} , S〉, 〈 q_b , \square, \square, q_{b1} , S〉, \\&

〈 q_{a1} , a, \square, q_2 , S〉,〈 q_{a1} , b, b, q_A , F〉,〈 q_{b1} , a, a, q_A , F〉,〈 q_{b1} , b, \square, q_2 , S〉, \\&

〈 q_2 , a, a, q_2 , S〉, 〈 q_2 , b, b, q_2 , S〉, 〈 q_2 , \square, \square, q_0 , D〉,\\&

〈 q_0 , \square, \square, q_R , F〉,\\&

〈 q_{a1} , \square, \square, q_A , F〉,   〈 q_{b1} , \square, \square, q_A , F〉   
\end{align}$$
Ora, costruiamo la macchina $T’_{PAL}$ che ha due  nastri: dopo aver copiato l’input x (che inizialmente è scritto sul nastro 1) sul nastro 2, T usa il nastro 1 per simulare $T_{PAL1}(x)$ e il nastro 2 per simulare $T_{PAL2}(x)$.
Costruiamo la macchina $T’_{PAL}$ che opera in due fasi:
1. Durante la prima fase simula l’intera computazione $T_{PAL1}(aba)$;
2. Durante la seconda fase simula l’intera computazione $T_{PAL2}(aba)$.
Bene. Ora eseguiamo la computazione $T’_{PAL}(bab)$  (che, ad un certo punto, dovrà eseguire la quintupla $〈 q_{a1} , \square, \square, q_{a1} , F〉$ - e, quindi, andrà in loop.
Osservate che $aba\in L_{PPAL}^C$ : quindi, $T’_{PAL}(aba)$ dovrebbe rigettare.
Ma aba è una parola palindroma di lunghezza dispari con ‘a’ al centro, e quindi, poiché $T’_{PAL}$ simula prima l’intera computazione $T_{PAL1}(bab)$, $T’_{PAL}$ non termina.
Ecco perché "un passo alla volta".
>[!danger]- Esercizi d'esame
>1. Dimostrare che, se $L_1$ e $L_2$ sono due linguaggi accettabili, allora $L_1\cup L_2$  è accettabile;
>2. Dimostrare che, se $L_1$ e $L_2$ sono due linguaggi accettabili, allora $L_1\cap L_2$  è accettabile. 
>3. In una delle due dimostrazioni è possibile prima simulare l’intera computazione di una macchina e poi l’intera computazione della seconda macchina: in quale dimostrazione? La soluzione la trovate sulle dispense.

## Funzioni calcolabili
Torniamo, per un momento, ai trasduttori: macchine di Turing dotate di nastro di output, che sanno calcolare il valore di una funzione generica – scrivendo tale valore sul nastro di output e terminando la computazione nello stato $q_F$.
Ad esempio:
$$\begin{align} \\&
f(n) = n^2\space nel\space punto\space n = 5, vale\space 25 – ossia, f(5) = 25 \\&

f(n) = 2^n\space nel\space punto\space n = 9, vale\space 512 - ossia, f(9)=512
\\&
E\space f(n) =\frac {1}{n-4}\space nel\space punto\space n = 4\space vale … \end{align}$$
Allora, intanto ci limitiamo a considerare funzioni ”discrete” – ossia, dati due alfabeti (finiti, neanche a dirlo) $\Sigma_1$ e $\Sigma_2$, noi consideriamo funzioni $f : \Sigma_1^*\to \Sigma_2^*$ (ossia, funzioni che trasformano parole in altre parole)
Poi, noi vogliamo calcolarle solo dove sono definite
E, poiché $f(n) =\frac{1}{n-4}$  non è definita nel punto n = 4, non possiamo (né vogliamo!) calcolare f(4).
E, infatti, parliamo di *funzioni* in generale (che possono non essere definite in alcuni punti) e di **funzioni totali** (che sono definite per ogni $x\in\Sigma_1^*$)
Una funzione $f : \Sigma_1^*\to \Sigma_2^*$ è **calcolabile** se esiste una macchina di Turing di tipo trasduttore T tale che,*per ogni $x\in\Sigma_1^*$ tale che f(x) è definita*, T(x)=f(x) (ossia, quando f(x) è definita, la computazione T(x) termina con la parola f(x) scritta sul nastro di output).
